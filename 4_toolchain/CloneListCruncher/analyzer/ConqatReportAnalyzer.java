package analyzer;
import static control.CloneListCruncher.REPORTFOLDER;
import static control.CloneListCruncher.sourceData;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import util.Log;
import data.Clone;

/**
 * conqatReportAnalyzer
 * This is a helper tool to analyze the cloning reports generated by conqat.
 * (c) 2014 Ivan Bogicevic
 * 
 * @author ivan
 */

public class ConqatReportAnalyzer extends ReportAnalyzer {

	// analyzes a single clone pair and add its result to the table
	private Clone analyzeClonePair(Element cloneLeft, Element cloneRight, String tool, String language, int solutionSet) {

		int cloneLeftFileName = Integer.parseInt(cloneLeft.getAttribute("sourceFileId")) + 1;
		int cloneRightFileName = Integer.parseInt(cloneRight.getAttribute("sourceFileId")) + 1;

		// check if partial or full clone
		int cloneLeftStartLine = Integer.parseInt(cloneLeft.getAttribute("startLine"));
		int cloneLeftEndLine = Integer.parseInt(cloneLeft.getAttribute("endLine"));
		int cloneRightStartLine = Integer.parseInt(cloneRight.getAttribute("startLine"));
		int cloneRightEndLine = Integer.parseInt(cloneRight.getAttribute("endLine"));
		int cloneLeftLength = (cloneLeftEndLine - cloneLeftStartLine);
		int cloneRightLength = (cloneRightEndLine - cloneRightStartLine);
		// full clone if both clone lengths are long enough
		int leftLength = sourceData.getFileLength(language, solutionSet, cloneLeftFileName);
		int rightLength = sourceData.getFileLength(language, solutionSet, cloneRightFileName);
		boolean isFull = (cloneLeftLength >= leftLength - 2)
				&& (cloneRightLength >= rightLength - 2);
		Log.debug("cloneLeftLength/fileLeftLength = " + cloneLeftLength + "/" + leftLength);
		Log.debug("cloneRightLength/fileRightLength = " + cloneRightLength + "/" + rightLength);

		// check clone type
		String cloneLeftGap = cloneLeft.getAttribute("gaps");
		String cloneRightGap = cloneRight.getAttribute("gaps");
		int type;
		if (cloneLeftGap.length() > 0 || cloneRightGap.length() > 0) {
			// there is a gap, so type 3 (4 cannot be detected by conqat)
			type = 3;
		} else {
			// there is no gap, so type 2 (or 1, but thats ignored here)
			type = 2;
		}		

		// add result to table
		Clone clone = new Clone(language, solutionSet, cloneLeftFileName,
				cloneLeftStartLine, cloneLeftEndLine, cloneRightFileName, cloneRightStartLine,
				cloneRightEndLine, isFull, type);
		Clone unifiedClone = addUnifiedCloneToTable(clone);
		return unifiedClone;
	}

	// read a conqat report and analyze the results
	@Override
	public List<Clone> analyzeSolutionSetReport(String language, int solutionSet) {

		// the list of clones for a specific tool, language and solution set
		List<Clone> localCloneList = new ArrayList<Clone>();

		// the local path to the conqat result xml
		String inputPath = REPORTFOLDER
				+ File.separator + getToolName()
				+ File.separator + language
				+ File.separator + solutionSet
				+ File.separator + "clones-gapped.xml";

		// show progress
		Log.star();

		// parse the xml file
		File xml = new File(inputPath);
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;
		try {
			// parse xml
			db = dbf.newDocumentBuilder();
			Document doc;
			doc = db.parse(xml);
			doc.getDocumentElement().normalize();

			// iterate through clone classes
			NodeList cloneClasses = doc.getElementsByTagName("cloneClass");
			for (int i = 0; i < cloneClasses.getLength(); i++) {
				Node cloneClass = cloneClasses.item(i);
				if (cloneClass.getNodeType() != Node.ELEMENT_NODE) {
					continue;
				}
				Element ccElement = (Element) cloneClass;
				Log.debug("\nanalyzing clone class id=" + ccElement.getAttribute("id"));

				// iterate through clones within the clone class
				NodeList clones = cloneClass.getChildNodes();
				List<Element> cElements = new ArrayList<Element>();
				// get clones of that class
				for (int i2 = 0; i2 < clones.getLength(); i2++) {
					Node clone = clones.item(i2);
					if (!(clone.getNodeType() == Node.ELEMENT_NODE && clone.getNodeName().equals("clone"))) {
						continue;
					}
					Element cElement = (Element) clone;
					cElements.add(cElement);
					Log.debug("analyzing clone id=" + cElement.getAttribute("id"));
				}

				// get clone pairs of that class
				for (int left = 0; left < cElements.size() - 1; left++){
					for (int right = left + 1; right < cElements.size(); right++){
						Element cloneLeft = cElements.get(left);
						Element cloneRight = cElements.get(right);
						Log.debug("analyzing clone pair id=" + cloneLeft.getAttribute("id") + " and " + cloneRight.getAttribute("id"));
						Clone clone = analyzeClonePair(cloneLeft, cloneRight, getToolName(), language, solutionSet);
						if (clone != null) {
							localCloneList.add(clone);
						}
					}
				}

			}
		} catch (ParserConfigurationException | SAXException | IOException e) {
			e.printStackTrace();
		}

		return localCloneList;
	}

	@Override
	public String getToolName() {
		return "conqat";
	}

}